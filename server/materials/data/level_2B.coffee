import label from "../lib/label"
import level from "../lib/level"
import page from "../lib/page"
import problem from "../lib/problem"
import topic from "../lib/topic"

module25835 = () ->
    page("Разбор задачи \"Путешествие\", читать только тем, кто ее решил!", String.raw"""
        <div class="box generalbox generalboxcontent boxaligncenter clearfix"><p>Задачу "Путешествие" почему-то очень многие из вас решают очень сложно. На самом деле у этой задачи есть очень простое и короткое решение.</p>
        
        <p>Давайте для начала научимся решать задачу, когда решение существует (т.е. когда ответ не -1). Представьте, что вы едете по дороге. Вы проезжаете очередную заправку. Надо ли вам тут заправляться? Ответ очевиден: если на текущем запасе бензина вы доедете до следующей заправки, то не надо, иначе надо. Этот алгоритм элементарно реализуется, для простоты даже лучше хранить не остаток бензина (он постоянно меняется), а координату, до которой мы можем доехать на текущей заправке (она меняется только при заправках), или, что эквивалентно, информацию, где мы последний раз заправлялись (координату или номер заправки).</p>
        
        <p>Слегка альтернативный подход, но по сути то же самое — т.к. мы решаем задачу, а не едем по трассе, то мы всегда можем "отмотать" время назад. Поэтому едем по трассе, если видим, что до очередной заправки у нас не хватило бензина, то "отматываем" время назад и решаем, что надо бы заправиться на предыдущей заправке.</p>
        
        <p>Для удобства реализации можно в конец массива заправок добавить заправку с координатой $N$ (т.е. с координатой пункта назначения). При любой разумной реализации вы никогда в ней заправляться не будете, зато в основном цикле вам не придется особо рассматривать последний отрезок пути.</p>
        
        <p>Осталось научиться определять, когда ответ -1. Вообще, несложно понять, что ответ -1 тогда и только тогда, когда есть две заправки подряд, расстояние между которыми больше $k$. Это можно проверить заранее, или можно по ходу основного цикла, когда мы решаем заправиться, сразу проверять, сможем ли мы доехать хотя бы до следующей заправки.</p>
        
        <p>Вот два примера решений, которые реализуют этот простой алгоритм:</p>
        
        <pre>// Автор — Саддамбек Нурланбек уулу, комментарии мои (П.К.)
        #include <iostream>
         
        using namespace std;
         
        int k, q, c, n, a[1111];
         
        int main(){
              cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
         
              // ввод данных
              for(int i = 1;i &lt;= s;++i){
                    cin &gt;&gt; a[i];
                    // сразу проверяем, есть ли решение 
                    if(a[i] -  a[i - 1] &gt; k){
                          cout &lt;&lt; -1;
                          return 0;
                    }
              }
        
              // l - номер заправки, где заправлялись последний раз
              // (всё решение, и выше тоже, предполагает, что в a[0] == 0 изначально, 
              // это на самом деле не очень хорошо)
              int l = 0;
         
              // добавляем заправку в пункте назначения
              a[++s] = n;
         
              for(int i = 1;i &lt;= s;++i){
                    // если до текущей заправки доехать не можем
                    if(a[i] - a[l] &gt; k){
                          c++;
                          // заправляемся в предыдущем пункте
                          l = i - 1;
                    }
              }
         
              cout &lt;&lt; c;
        }
        </iostream></pre>
        <hr>
        <pre># Автор — Андрей Ефремов, комментарии мои (П.К.)
        n, k = [int(i) for i in input().split()]
        s = [int(i) for i in input().split()]
        
        # добавили заправку "очень далеко"
        s.append(2000)
        
        ans = 0
        
        # now = до какой координаты можем доехать при текущем запасе бензина
        now = k
        
        i = 1
        # пока не можем доехать до финиша
        while now &lt; n:
            # если не можем доехать до следующей заправки
            if s[i + 1] &gt; now:
                # если и до текущей не можем, то решения нет
                if s[i] &gt; now:
                    print(-1)
                    break
                else:
                    # иначе надо заправиться на текущей заправке
                    ans += 1
                    now = s[i] + k
            i += 1
        # else после while в питоне работает только если из while мы вышли не по break
        else:
            print(ans)
        </pre></div>
    """, {skipTree: true})

topic_module_52198_0 = () ->
    return topic("Сложность алгоритмов (без контеста)", null, [
        label("<a href=\"https://notes.algoprog.ru/complexity/index.html\">Теория про сложность алгоритмов (самое важное в разделе «O-обозначение для оценки сложности алгоритмов»; про P и NP читать не обязательно)</a>"),
    ])

topic_16044 = () ->
    return topic("Простые числа и разложение на множители", "2Б: Задачи на множители", [
        label("См. <a href=\"https://sis.khashaev.ru/2013/august/c-prime/\">видеозаписи лекций ЛКШ параллели C'</a>, раздел «Арифметические алгоритмы»"),
        problem(310),
        problem(623),
        problem(973),
    ])

module25226 = () ->
    page("Про жадные алгоритмы", String.raw"""
        <div class="box generalbox generalboxcontent boxaligncenter clearfix"><h2>"Жадные" алгоритмы</h2>
        <p>Жадные алгоритмы — это алгоритмы, которые, на каждом шагу принимают локально оптимальное решение, не заботясь о том, что будет дальше. Они не всегда верны, но есть задачи, где жадные алгоритмы работают правильно.</p>
        
        <p>Пример жадного алгоритма следующий. Вспомните <a href="/material/p915" onclick="window.goto('/material/p915')();return false;">задачу "Платная лестница"</a> из контеста на ДП. Правильное решение в этой задаче — это именно динамика, но в этой задаче можно также придумать и следующее жадное решение (правда, неправильное). На каждом шагу у нас есть два варианта — подняться на следующую ступеньку или перепрыгнуть через ступеньку. Вот посмотрим, какой из этих двух вариантов дешевле, т.е. на какой из этих ступенек меньше цена, и сделаем такой шаг.</p>
        
        <p>Конечно, это решение неправильное, вот пример. Если на ступеньках написаны следующие числа:</p>
        <pre>1 2 10 2
        </pre>
        <p>то жадный алгоритм увидит, что изначально у него есть два варианта: сходить на ступеньку с числом 1 или с числом 2 — и пойдет на ступеньку с числом 1, т.к. это дешевле. Но правильное решение здесь — пойти на ступеньку с числом 2, т.к. потом мы сможешь перепрыгнуть ступеньку с числом 10.</p>
        
        <p>Этот пример четко показывает, почему жадные алгоритмы обычно не работают. Они не учитывают далекие последствия своих действий, они делают выбор, который оптимален только с учетом ближайших перспектив.</p>
        
        <p>(Сразу отмечу, что нередко жадные алгоритмы хочется применить в задачах на ДП. Да, многие задачи на жадность и на ДП похожи, просто в жадном алгоритме вы доказываете, что вариантов рассматривать не надо, а в ДП вы их честно рассматриваете. Поэтому если жадность не работает, то подумайте, не получится ли тут придумать ДП. Но на самом деле есть и много задач на жадность, где ДП не особенно придумаешь, и много задач на жадность, которые вообще не похожи на ДП.)</p>
        
        <p>Но бывают задачи, в которых жадность все-таки работает, в которых можно <i>доказать</i>, что жадный алгоритм корректен. На самом деле, в наиболее простых задачах корректность жадности очевидна (и на этом уровне у вас в основном будут именно задачи такого типа, более продвинутые будут на уровне 6Б), еще в некоторых задачах корректность жадности может быть не очевидна (или даже может быть несколько разных жадных алгоритмов, которые можно придумать, и непонятно, какой из них правильный), но вы можете написать жадность, отправить на проверку (если это возможно на конкретной олимпиаде) и сразу узнать, корректна она или нет. Наконец, даже если жадность некорректна, она нередко работает в простых случаях, поэтому жадные алгоритмы нередко неплохо подходят на роль частичных решений.</p>
        
        <h3>Как доказывать жадность?</h3>
        
        <p>Как обычно доказывают жадные алгоритмы? На самом деле, на текущем уровне вам не обязательно научиться их доказывать, но если поймете, что написано ниже, то будет хорошо.</p>
        
        <p>Есть два подхода к доказательству задач на жадность. Первый вариант более общий. Он может быть применен в тех задачах, где вам надо сделать несколько последовательных шагов, несколько последовательных выборов. (В примере задачи про платную лестницу выше — вы именно делаете несколько последовательных выборов "на какую ступеньку сходить".) Вам надо доказать, что если вы сделаете локально оптимальный выбор, то он не отменит возможность придти к глобально оптимальному решению. Обычно доказательство идет так: возьмем решение, построенное жадным алгоритмом, возьмем оптимальное решение, найдем первый шаг, где они отличаются, и докажем, что оптимальное решение можно поменять так, чтобы оно осталось оптимальным, но этот отличающийся шаг стал совпадать с жадным решением. Тогда мы имеем оптимальное решение, которое совпадает с жадным на один шаг дальше. Тогда очевидно, что есть оптимальное решение, которое полностью совпадает с жадным, т.е. что жадное является оптимальным.</p>
        
        
        <p>Пример. Пусть у нас задача: есть $N$ вещей, каждая со своим весом. Надо выбрать как можно больше вещей так, чтобы суммарный вес не превосходил заданного числа $C$. Очевидное жадное решение: брать вещи, начиная с самой легкой, пока суммарный вес не превосходит $C$. Как только превзошел — все, выводим ответ.</p>
        
        <p>Давайте докажем. Рассмотрим жадное решение, оно берет себе вещи в порядке возрастания веса. Рассмотрим оптимальное решение и рассмотрим первый шаг, когда в жадном решении мы отклонились от оптимального. Это значит, что в жадном решении мы взяли вещь (пусть это вещь $X$), которая не входит в оптимальное решение. Значит, в оптимальном решении должна быть какая-то вещь (пусть это вещь $Y$), которой нет в жадном, иначе в жадном решении было бы больше вещей, чем в оптимальном, что противоречит оптимальности. При этом вещь $Y$ не легче, чем вещь $X$, т.к. в жадном решении мы брали все вещи в порядке возрастания веса. Тогда возьмем оптимальное решение, и заменим в нем вещь $Y$ на вещь $X$. Суммарный вес вещей в оптимальном решении не увеличится, количество вещей не уменьшится, поэтому решение по-прежнему будет оптимальным. Но оно будет совпадать с жадным на шаг дальше. ЧТД.</p>
        
        <p>Второй вариант доказательства подходит к тем задачам, где вам надо выбрать некоторый <i>порядок</i> предметов: набор предметов вам задан, а надо выбрать, в каком порядке их расположить, чтобы что-то оптимизировать. Тогда вы можете попробовать доказать, что предметы надо расположить в порядке возрастания некоторого параметра (это и будет жадным алгоритмом). Доказательство будет таким: пусть в оптимальном решении предметы идут не в таком порядке. Тогда найдем два соседних предмета, которые идут в неправильном порядке, и поменяем их местами, и докажем, что решение не ухудшится, а значит, останется оптимальным. Тогда очевидно, что жадное решение (которое расставляет предметы в порядке возрастания этого параметра) будет корректным.</p>
        
        <p>Пример. В олимпиадах типа ACM участники решают задачи. За каждую решенную задачу они получают штраф, равный времени, прошедшему с начала тура до момента решения этой задачи. Предположим, что у нас есть идеальная команда, и она тратит $t_i$ минут на решение $i$-й задачи (и никогда не делает неудачных попыток). В каком порядке им надо решать задачи, чтобы получить минимальный штраф?</p>
        
        <p>Жадный алгоритм: в порядке возрастания $t_i$. Доказательство. Пусть у нас есть оптимальное решение, в котором $t_i$ не отсортированы по возрастанию. Найдем две задачи, $i$ и $j$, такие, что в оптимальном решении мы решаем сначала решаем задачу $i$, а сразу после нее задачу $j$, при этом $t_i&gt;=t_j$. Поменяем их местами. Что изменится в плане штрафного времени? Для всех задач, которые мы решали до этих двух, штрафное время не изменится. Для всех задач, которые мы решали после этих двух, штрафное время тоже не изменится. (Именно для этого мы и брали соседние задачи.) Штрафное же время по этим задачам было $t_i+(t_i+t_j)$, а стало $t_j+(t_i+t_j)$. Поскольку $t_i&gt;=t_j$, то решение не ухудшилось, значит, оно осталось оптимальным. ЧТД.</p>
        
        <p>(Оба доказательства выше в принципе можно переформулировать на доказательства от противного: что если оптимальное решение сильно отличается от жадного, то мы меняем оптимальное решение, получаем решение, которое строго лучше, значит, оптимальное решение было не оптимальным. Да, так доказывать тоже можно, но надо аккуратно обойтись со случаем равных значений — случаем $t_i=t_j$ или случаем двух вещей одного веса в первой задаче.)</p>
        
        <p>На самом деле, второй вариант доказательства на самом деле позволяет <i>придумывать</i> жадность в тех задачах, где она не очевидна (если не поймете этот абзац, то не страшно). Если вам в задаче надо расположить объекты в некотором порядке, и вы не знаете, в каком, подумайте: пусть у вас есть некоторый порядок. Поменяем местами два соседних предмета, посмотрим, как изменится решение. Пусть оценка старого решения была $X$, а нового — $Y$ (это, конечно, функция решения). Напишем условие $X&gt;Y$, т.е. что решение улучшилось. Попробуем его преобразовать так, чтобы свести все к характеристикам двух объектов, которые мы меняем местами. Тогда, может быть, мы обнаружим, что условие $X&gt;Y$ эквивалентно условию $f(i)&gt;f(j)$, где $i$ и $j$ — предметы, которые мы поменяли местами, а $f$ — какая-то функция. Тогда очевидно, что в правильном решении надо просто отсортировать предметы по значению функции $f$.</p></div>
    """, {skipTree: true})

topic_25224 = () ->
    return topic("Простая жадность", "2Б: Задачи на простую жадность", [
        module25226(),
        problem(1576),
        problem(2826),
        problem(113075),
    ])

module17576 = () ->
    page("О связи перебора и ДП, или Как переборные решения превращать в ДП", String.raw"""
        <div class="box generalbox generalboxcontent boxaligncenter clearfix"><h1>О связи перебора и ДП, или Как переборные решения превращать в ДП</h1>
        <p>(Со временем я добавлю этот текст в основной текст про ДП. Этот материал не является обязательным на уровне 3. Если вы не освоили рекурсивный перебор, то пропустите и этот материал. Если вы освоили рекурсивный перебор, то прочитайте этот текст и постарайтесь его понять, хотя на самом деле для решения задач уровня 3 идеи, изложенные ниже, не обязательны, на уровне 3 в ДП задачи довольно простые.)</p>
        
        <h2>Пример: последовательности из нулей и единиц</h2>
        
        <p>Пусть вы придумали переборное решение к некоторой задаче. Часто бывает так, что его несложно превратить в решение динамическим программированием. Например, рассмотрим нашу любимую задачу про последовательности из нулей и единиц без двух единиц подряд. Пусть мы не додумались до решения ДП. Давайте напишем переборное решение с адекватными отсечениями:</p>
        <pre>var ans:integer;
            a:array[1..100] of integer;
            n:integer;
        
        procedure check;
        begin
        inc(ans);
        end;
        
        procedure find(i:integer);
        begin
        if i&gt;n then begin
            check;
            exit;
        end;
        a[i]:=0;
        find(i+1);
        if (i=1)or(a[i-1]=0) then begin
            a[i]:=1;
            find(i+1);
        end;
        end;
        
        begin
        read(n);
        ans:=0;
        find(1);
        writeln(ans);
        end.
        </pre>
        
        <p>У этой реализации есть недостаток, который нам будет сейчас мешать — это глобальная переменная <code>ans</code>. Давайте перепишем код так, чтобы он не использовал глобальную переменную: сделаем все процедуры <i>функциями</i>, возвращающими, <i>сколько последовательностей они нашли:</i></p>
        <pre>var ans:integer;
            a:array[1..100] of integer;
            n:integer;
        
        function check:integer;
        begin
        result:=1;
        end;
        
        function find(i:integer):integer;
        begin
        if i&gt;n then begin
            result:=check;
            exit;
        end;
        a[i]:=0;
        result:=find(i+1);
        if (i=1)or(a[i-1]=0) then begin
            a[i]:=1;
            result:=result+find(i+1);
        end;
        end;
        
        begin
        read(n);
        ans:=find(1);
        writeln(ans);
        end.
        </pre>
        <p>Т.е. помните мотивировку рекурсивного перебора? "Функция <code>find</code> предполагает, что мы уже заполнили первые $i-1$ элементов массива и перебирает варианты заполнения оставшихся." Так вот, в модифицированном варианте функция будет еще и <i>возвращать</i> количество способов заполнить оставшиеся. Осознайте, почему это работает.</p>
        
        <p>А теперь самое главное. Зададимся вопросом: <i>от чего на самом деле зависит результат работы функции <code>find</code>?</i> Пусть, например, мы рассматриваем запуск <code>find(15)</code>. Это обозначает, что мы заполнили первые 14 элементов массива. Так вот: зависит ли возвращаемое значение функции <code>find(15)</code> от <i>всех значений всех этих элементов</i>?</p>
        
        <p>Достаточно очевидно, что нет. Более того, если подумать, то понятно, что возвращаемое значение зависит только от собственно <code>i</code>, а также от значения <code>a[i-1]</code>. Значения предыдущих элементов массива нам не важны. Например, результат вызова <code>find(5)</code> будет один и тот же, если массив <code>a</code> перед вызовом равен <code>1 0 1 1</code> или <code>0 1 1 1</code>, но для массива <code>1 0 1 0</code> результат будет другой.</p>
        
        <p>Это позволяет резко ускорить решение, причем двумя способами. Первый способ состоит в том, чтобы распознавать ситуации, эквивалентные тем, которые мы уже решали раньше — и не перерешивать заново. А именно, пусть мы запускаем <code>find(i)</code>, и при этом <code>a[i-1]=x</code>. Запишем результат этой процедуры в специальный массив <code>res</code> в элемент <code>res[i,x]</code>. После этого когда окажется, что мы опять запускаем <code>find(i)</code> с тем же самым <code>i</code> и тем же самым <code>a[i-1]</code>, то мы не будем все рассчитывать заново, а просто сразу вернем значение, уже записанное в <code>res[i,x]</code>. Примерно так:</p>
        <pre>var res:array[1..100,0..1] of integer;
            ...
        
        function find(i:integer):integer;
        begin
        if i&gt;n then begin
            result:=check;
            exit;
        end;
        if res[i,a[i-1]]=-1 then begin // если мы еще не решали эту задачу
            a[i]:=0;
            res[i,a[i-1]]:=find(i+1);
            if (i=1)or(a[i-1]=0) then begin
                a[i]:=1;
                res[i,a[i-1]]:=res[i,a[i-1]]+find(i+1);
            end;
        end;
        result:=res[i,a[i-1]];
        end;
        </pre>
        <p>Это еще не совсем рабочий код, в нем надо как минимум аккуратно разобраться со случаем <code>i=1</code>, а еще можно и функцию <code>check</code> исключить, но, я думаю, идея понятна. Собственно, это то, что называется рекурсией с запоминанием результата, и это уже полноценное ДП.</p>
        
        <p>Но чтобы более четко понять, что происходит, и написать уже совсем классическое ДП, пойдем немного другим способом. А именно, заметив, что ответ зависит только от <code>i</code> и <code>a[i-1]</code>, попробуем сразу это и сделать подзадачами ДП. А именно, давайте для каждого <code>i</code> и <code>x</code> вычислим <code>res[i,x]</code> как значение, которое вернет наша функция <code>find(i)</code>, запущенная в ситуации, когда <code>a[i-1]=x</code>. Результат функции зависит только от <code>i</code> и <code>x</code>, поэтому наш вопрос корректен.</p>
        
        <p>Как мы будем вычислять <code>res[i,x]</code>? У нас уже есть функция <code>find</code>, и она фактически документирует способ этого вычисления. Во-первых, если <code>i&gt;n</code>, то ответ будет <code>1</code>. Иначе функция <code>find</code> рекурсивно запускает себя один или два раза в зависимости от <code>a[i-1]</code> (т.е. <code>x</code>). Несложно прямо из когда нашей функции видеть, что выполняется следующее соотношение:</p>
        <pre>res[i,x]=res[i+1,0]             если x=1
        res[i,x]=res[i+1,0]+res[i+1,1]  если x=0
        </pre>
        
        <p>Вот и готова динамика! Несложно также видеть, что нам надо идти по убыванию <code>i</code>, т.к. каждая подзадача зависит от подзадач с бОльшим <code>i</code>, и теперь решение пишется легко:</p>
        <pre>res[n+1,0]:=1;
        res[n+1,1]:=1; // это особые случаи, отвечающие функции check
        for i:=n downto 1 do begin
            res[i,1]:=res[i+1,0];
            res[i,0]:=res[i+1,0]+res[i+1,1];
        end;
        writeln(res[1,0]); // поймите, почему именно так?
        </pre>
        
        <p>Вот и все. Мы придумали подзадачи и получили рекуррентное соотношение, просто задавшись одним вопросом: от чего на самом деле зависит результат функции <code>find</code>?</p>
        
        <p>Конечно, его можно улучшить: можно первую формулу подставить во вторую:</p>
        <pre>res[i,0]=res[i+1,0]+res[i+2,0]
        </pre>
        <p>И теперь мы видим, что элементы с <code>x=1</code> нам больше не нужны, и переобозначая <code>res[i,0]</code> как просто <code>res[i]</code>, получаем уже привычное рекуррентное соотношение для этой задачи. Правда, пожалуй, рекуррентные соотношения с двумя элементами массива, в общем-то, представляются даже более естественными для этой задачи.</p>
        
        <p>Оно (да и рекуррентные соотношения выше), правда, записано "задом-наперед", но это не так страшно. Если подумать, то все понятно: в обычной динамике мы задавались вопросом "как можно заполнить первые <code>i</code> позиций" (т.е. сколько есть решений длины <code>i</code>), а тут мы задаемся вопросов "как можно заполнить последние <code>n-i</code> позиций" (так и работал перебор). Поэтому и цикл от <code>n</code> вниз, и рекуррентное соотношение ссылается на бОльшие <code>i</code>. Но это уже детали. </p>
        
        <h2>Общая идея</h2>
        <p>Итак, общая идея. Пусть вы придумали переборное решение к некоторой задаче. Придумайте его так, чтобы ваша функция <code>find</code> <i>возвращала</i> результат, а не работала бы с какими-нибудь глобальными переменными. Подумайте, от чего зависит результат, возвращаемый вашей функцией. Часто он будет зависеть не от всего множества выборов, которые вы сделали раньше, а от некоторой характеристики этого множества. Отлично, теперь вот все возможные значения этой характеристики (или нескольких характеристик) и станут подзадачами в вашей динамике; а то, как работала бы ваша функция, станет рекуррентным соотношением.</p>
        
        <p>Вам даже не обязательно непосредственно <i>писать</i> рекурсивный код; вы можете просто <i>представить</i> его в уме.</p>
        
        <p>Конечно, этот подход будет работать не всегда. Зачастую задачу можно решить перебором разными способами, и только некоторые из них приведут к хорошему решению динамикой. Но тем не менее подход, как мне кажется, весьма полезен.</p>
        
        <h2>Пример: набор заданной суммы данным набором монет</h2>
        <p>Нам надо набрать некоторую сумму <code>S</code>, используя монеты достоинством <code>a[1]</code>, <code>a[2]</code>, ..., <code>a[n]</code>. Каждую монету можно использовать не более одного раза.</p>
        
        <p>Давайте придумаем переборное решение. Помня, что динамика из перебора получается "задом-наперед", я сразу придумаю перебор "задом-наперед", чтобы динамика получилась нормальной. А именно, я буду запускать из главной программы <code>find(n)</code>, она будет решать, берем ли мы <code>n</code>-ую монету и запускать <code>find(n-1)</code> и т.д.:</p>
        
        <pre>function check:boolean;
        var cursum:integer;
            i:integer;
        begin
        for i:=1 to n do
            if taken[i]=1 then
                cursum:=cursum+a[i];
        result:=cursum=s;
        end;
        
        function find(i:integer):boolean;
        begin
        if i=0 then begin
            result:=check;
            exit;
        end;
        taken[i]:=0;
        result:=find(i-1);
        taken[i]:=1;
        result:=result or find(i-1);
        end;
        
        begin
        ...
        fillchar(taken,sizeof(taken),0);
        res:=find(n);
        writeln(res);
        end.
        </pre>
        
        <p>Я даже тут не стал делать никаких отсечений. Я просто перебираю все варианты "брать-не брать" и потом проверяю, получилась ли нужная сумма.</p>
        
        <p>Давайте подумаем, от чего зависит результат функции <code>find</code>. Если немного подумать, то несложно понять, что нам действительно не надо знать, какие конкретно числа мы поставили в массив <code>taken</code>, т.е. какие конкретно монеты мы решили брать. Нам надо лишь знать <i>общую сумму</i>, которую мы уже набрали этими монетами. Ну и <code>i</code>, конечно, тоже надо знать.</p>
        
        <p>Обозначая уже набранную сумму как <code>x</code>, получаем сразу рекуррентное соотношение для динамики:</p>
        
        <code>
        res[i,x]=res[i-1,x] or res[i-1,x+a[i]]
        </code>
        
        <p>Собственно, это и есть стандартное рекуррентное соотношение для этой задачи; только обычно вместо <code>x</code> используют <code>S-x</code> — сумму, которую <i>осталось</i> набрать, но это несущественно. Кроме того, можно только еще догадаться, что решать подзадачи с <code>x&gt;S</code> не надо — и добавить соответствующий <code>if</code>, но это уже технические детали, которые несложно добавить (да и не всегда необходимо).</p>
        
        <p>Так что обратите внимание еще раз на то, как легко мы придумали эти подзадачи. Если вы не думали про перебор, то может показаться очень неочевидным, что параметром динамики надо взять <i>сумму, которую надо набрать</i> (или которую уже набрали) — но если вы уже подумали про переборное решение и задались вопросом "от чего зависит результат вызова <code>find</code>" — то это становится почти очевидным.</p></div>
    """, {skipTree: true})

topic_16038 = () ->
    return topic("Основы динамического программирования", "2Б: Простые задачи на ДП", [
        label("<a href=\"https://notes.algoprog.ru/dynprog/index.html\">Теория про ДП</a> (вплоть до самой провинутой, пока читайте только основы)"),
        module17576(),
        label("<div style=\"display:inline-block;\">См. также <a href=\"https://sis.khashaev.ru/2013/august/c-prime/\">видеозаписи лекций ЛКШ параллели C'</a>, раздел «Динамические программирование»<br>\nСм. также <a href=\"https://sis.khashaev.ru/2008/august/b-prime/\">видеозаписи лекций ЛКШ параллели B'.2008</a>, раздел «Динамические программирование» (в параллели B' уже есть и довольно продвинутые темы, которые вам пока не нужны)</div>"),
        problem(201),
        problem(842),
        problem(843),
        problem(913),
        problem(912),
        problem(914),
        problem(203),
        problem(915),
        problem(206),
        problem(944),
    ])

topic_16041 = () ->
    return topic("Стек, дек, очередь", "2Б: Задачи на стек, очередь и дек", [
        label("Теории по этим темам тут пока нет, но очень много теории есть в интернете. Вот, например, что я нашел: <a href=\"https://algolist.manual.ru/ds/basic/\">раз</a>, <a href=\"https://brestprog.neocities.org/lections/datastructures.html\">два</a>."),
        problem(54),
        problem(58),
        problem(61),
        problem(50),
    ])

export default level_2B = () ->
    return level("2Б", [
        label("<p>Чтобы перейти на следующий уровень, необходимо решить все задачи.</p>"),
        topic_module_52198_0(),
        topic_16038(),
        topic_16041(),
        topic_16044(),
        topic_25224(),
        module25835(),
    ])